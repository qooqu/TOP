TODO

starter-dir
	add npm

todo project
	add localhost
	date etc fields in todo
	todo buttons


object constructors

	different ways of making objects

		literal
		constructor
		factory function
		module
		class

	things to know about objects generated by the above

		prototype

			stuff in the body of the constructor is duplicated onto the objects
			stuff in the prototype property of the constructor is used by the objects, but lives in the constructor

		inheritance

			you can make a child constructor that inherits the prototype of the parent constructor
			when a prototype-defined method is called on an object, js will walk up the prototype chain until it finds the method

		privacy / scoping

			some of the constructor types take advantage of function scope to allow you to hide its members from the outside world

		namespace

			fancy word for the name of an object
			if you put a bunch of related props and methods into a single object, the name of the object is the 'namespace' for those props and methods
			e.g. the 'book' namespace might include book.title, book.markAsRead(), etc

	https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance


	object literal

		this is when you just type it out

			bob = {
				name = 'bob',
				grade = 12
			}

		as far as I know, inheritance and prototype don't apply to literals

	object constructor

		a special category of function
		requires 'new' to invoke
		if you leave out 'new', weird things will happen

		basic version

			function Student(name, grade) {
				this.grade = grade
				this.name = name
			}
			
			let bob = new Student('bob', 5);
			bob.name // 'bob'
			
		with method ... wrong way (method will be repeated in each child object)

			function Student(name, grade) {
				this.name = name
				this.grade = grade
				this.sayName = function() {
					console.log(`Hi I'm ${name}.`)
				}
			}
			
		with method ... right way (method lives in only one place, js will use the protoype chain to find it)
		
			function Student(name, grade) {
				this.name = name
				this.grade = grade
			}

			Student.prototype.sayName = function() {
				console.log(`Hi I'm ${this.name}.`)
			}
			
			let bob = new Student('bob', 5);
			bob.sayName // Hi I'm bob.

		inheritance ... make a 'child' constructor

			function EighthGrader(name) {
				this.name = name
				this.grade = 8
			}

			EighthGrader.prototype = Object.create(Student.prototype)

			let bob = new EighthGrader('bob');
			bob.sayName // Hi I'm bob.


	factory function

		plain old function that returns an object
		doesn't need the 'new' keyword to invoke
		includes a return statement, so you can have private members
		
			const personFactory = (name, age) => {
				const sayHello = () => console.log('hello!');
				return { name, age, sayHello };
			};

			const jeff = personFactory('jeff', 27);

			console.log(jeff.name); // 'jeff'

			jeff.sayHello(); // calls the function and logs 'hello!'
			
		privacy
			
			only exposes members in the return statement
			closure: functions retain their scope even if they are passed around and called outside of that scope.
			
				const FactoryFunction = (string) => {
					const capitalizeString = () => string.toUpperCase();
					const printString = () => console.log(`----${capitalizeString()}----`);
					return { printString };
				};

				const taco = FactoryFunction('taco');

				printString(); // ERROR!!
				capitalizeString(); // ERROR!!
				taco.capitalizeString(); // ERROR!!
				taco.printString(); // this prints "----TACO----"

			capitalizeString is a private function and printString is public

			because capitalizeString isn't returned by the FF, we can't call it. but printString can.

			FF closures allow us to create private variables and functions that are used in the workings of our objects but are not intended to be used elsewhere in our program.
			
			In other words, even though our objects might only do one or two things, we are free to split our functions up as much as we want (allowing for cleaner, easier to read code) and only export the functions that the rest of the program is going to use.
		
		inheritance
		
			if the 'parent' returns something that you want the child to have, you can inherit it like this
			
				const Person = (name) => {
					const sayName = () => console.log(`my name is ${name}`)
					return {sayName}
				}

				const Nerd = (name) => {
					// create a person and pull out the sayName function with destructuring assignment syntax
					const {sayName} = Person(name)
					const doSomethingNerdy = () => console.log('nerd stuff')
					return {sayName, doSomethingNerdy}
				}

				const jeff = Nerd('jeff')

				jeff.sayName() //my name is jeff
				jeff.doSomethingNerdy() // nerd stuff
				
	module pattern ... different from ES6 modules (i.e. import / export modules)

		module pattern wraps a factory in an IIFE (Immediately Invoked Function Expression)
		basically a single use FF
		
		example 1
		
			const calculator = (() => {
				const add = (a, b) => a + b;
				const sub = (a, b) => a - b;
				const mul = (a, b) => a * b;
				const div = (a, b) => a / b;
				return {
					add,
					sub,
					mul,
					div,
				};
			})();

			calculator.add(3,5) // 8
			calculator.sub(6,2) // 4
			calculator.mul(14,5534) // 77476
			
		example 2 (note the underscores are a style thing, not required)

			var myModule = (function() {
				'use strict';

				var _privateProperty = 'Hello World';

				function _privateMethod() {
					console.log(_privateProperty);
				}

				return {
					publicMethod: function() {
						_privateMethod();
					}
				};
			})();

			myModule.publicMethod(); // outputs 'Hello World'
			console.log(myModule._privateProperty); // is undefined protected by the module closure
			myModule._privateMethod(); // is TypeError protected by the module closure

	classes

		the modern way of doing things
		requires 'new'
		js converts all the class stuff to ordinary constructors and prototypes behind the scenes
		note the functions are outside of the class's constructor for inheritance purposes

			class Person {
				constructor(first, last, age, gender, interests) {
					this.name = {
						first,
						last
					};
					this.age = age;
					this.gender = gender;
					this.interests = interests;
				}

				greeting() {
					console.log(`Hi! I'm ${this.name.first}`);
				};

				farewell() {
					console.log(`${this.name.first} has left the building. Bye for now!`);
				};
			}

			let han = new Person('Han', 'Solo', 25, 'male', ['Smuggling']);
			han.greeting(); // Hi! I'm Han

		inheritance
		
			class Teacher extends Person {
				constructor(first, last, age, gender, interests, subject, grade) {
					// need to call 'super', which will call the class that's getting extended (in this case Person)
					super(first, last, age, gender, interests);

					// subject and grade are specific to Teacher
					this.subject = subject;
					this.grade = grade;
				}
			}

			let snape = new Teacher('Severus', 'Snape', 58, 'male', ['Potions'], 'Dark arts', 5);
			snape.greeting(); // Hi! I'm Severus.
			snape.farewell(); // Severus has left the building. Bye for now.
			snape.age // 58
			snape.subject; // Dark arts
			
		classes have a special syntax around getters and setters. this is a dumb example, but they are useful when you need to run some code on a value before storing / retrieving
		
			class Teacher extends Person {
				constructor(first, last, age, gender, interests, subject, grade) {
					super(first, last, age, gender, interests);
					// subject and grade are specific to Teacher
					this._subject = subject;
					this.grade = grade;
				}

				get subject() {
					return this._subject;
				}

				set subject(newSubject) {
					this._subject = newSubject;
				}
			}
			
			let snape = new Teacher('Severus', 'Snape', 58, 'male', ['Potions'], 'Dark arts', 5);

			// Check the default value
			console.log(snape.subject) // Returns "Dark arts"

			// Change the value
			snape.subject = "Balloon animals" // Sets _subject to "Balloon animals"

			// Check it again and see if it matches the new value
			console.log(snape.subject) // Returns "Balloon animals"
			
		privacy
		
			supported by chrome and edge, but not by ff or safari
			so you can use this syntax, but only if you add babel to your project
		
			class ClassWithPrivateMethod {
				#privateMethod() {
					return 'hello world'
				}

				getPrivateMessage() {
					return this.#privateMethod()
				}
			}

			const instance = new ClassWithPrivateMethod()
			console.log(instance.getPrivateMessage()) // expected output: "hello worlâ€‹d"

npm, ES6 modules, webpack, babel

	npm

		node package manager
		make a new project folder
		cd into it
		run npm init
		npm will create a node_modules folder and a package.json file
		add packages to your project with `npm install --save <package name>`
			When installing a package that will be bundled into production, you should use --save. Installing for development purposes (e.g. a linter, testing libraries, etc.) should use npm install --save-dev.
		npm will download the package to node_modules and add it to the dependencies field in package.json
		in your code, you can access a package with `import <package name>`
		package.json should be included in git, node_modules should not
			exclude all node_modules by putting .gitignore at root with these lines
				# Ignore node_modules folder
				node_modules
		if you clone a repo with a package.json, you would then run `npm install` to get all the dependencies
		misc
			uninstall packages with: npm uninstall <package name>
			check version with: npm list <package name>
			upgrade with: npm update <package name>

	ES6 modules ... import / export

		write some chunk of code in its own file
		at the end of the file, use an `export` statement to make your chunk available elsewhere
		go to another file
		pull in whatever chunks you need with `import`

	webpack

		npm put all the dependency's code in node_modules. your code wants to access it with `import <package name>`. but browsers don't know how to connect them
		further, not all browsers can understand ES6 import / export
		webpack is a build step that addresses both issues
		npm install webpack webpack-cli --save
		npm install webpack-dev-server --save-dev
		make webpack.config.js (see below)
		make src and dist folders
		put index.html in dist, put all your code in src with index.js as the entry point
		webpack will create main.js in dist
		point index.html at main.js in dist

		webpack.config.js

			const path = require('path');

			module.exports = {
				entry: './src/index.js',
				output: {
					filename: 'main.js',
					path: path.resolve(__dirname, 'dist'),
				},
				devServer: {
					contentBase: path.resolve(__dirname, "dist"),
					watchContentBase: true,
				},
			};

	babel ... i haven't actually tried this yet

		browsers lag behind new js features
		babel transpiles modern js into old js that all browsers can understand
		npm install @babel/core @babel/preset-env babel-loader --save
		add babel rules to webpack.config.js

	back to npm

		add to package.json scripts
			"build": "webpack --progress --mode=production",
		    "watch": "webpack --progress --watch"
		    "serve": "webpack serve --mode development --env development"
		`npm run build` will bundle the site to src
		`npm run watch` will update the bundle as you make changes ... but you still have to refresh the browser to see the 		dev stuff
		`npm run serve` will serve the site to localhost and hot reload any changes

	starter-dir

		everything is set up
		copy starter-dir, rename it, cd into it, and run `npm install`
			note there's currently a bug. i got it to work by also running
				npm install webpack webpack-cli --save
				npm install webpack-dev-server --save-dev
